# X si 0

## About
This is a Tic Tac Toe game (or naughts and crosses game) for one or two players. At the start of the game the user can choose whether or not they want to play on a 3 by 3 matrix or a 4 by 4 one.

If you want to test it out simply download the code and run it in your compiler of choice.

## Code explained

Firstly, i use a function called *gametype* to display the game options to the player:

```cpp
void gameType() // noughts and crosses
{
	int tableOption, playerOption;
	cout << "Welcome to noughts and crosses! What kind of game do you want to play?\n";
	cout << "1. player vs player (PVP)\n";
	cout << "2. player versus enviroment/PC (PVE)\n";
	cin >> playerOption;
	cin.get();
	switch (playerOption)
	{
	case 1: {twoPlayerGame(); startOne(); } break;
	case 2: {onePlayerGame(); startTwo(); } break;
	}
}
```

The data structure i'm working with, a bidimensional table/ a matrix, gets the (self-explanatory) label *game*. It's declared globally and it formats it's content with the following rules: an element gets the value 1 for player X/ player 1 and the value 0 for player 0/ user2/ randomly generated value. To actually choose which square to change, the user (or users) needs to introduce the line and column of said square.

To choose the type of matrix displayed to the user I use a variable called *tableElements* which keeps the number of lines and columns chosen. This variable is globally declared at the satrt of the program since it appears in multiple functions.
 
```cpp
void tableSelection()
{
	int tableOption;
	cout << "What kind of table do you want to play on? 3 by 3 (1) or 4 by 4 (2) ?";
	cin >> tableOption;
	if (tableOption == 1) tableElements = 3;
	else tableElements = 4;
}
```

To save the names of the players I chose to use two string arrays (variable names being self-explanatory: *user1* and *user2* ). These strings were read in the *twoPlayerGame* or *onePlayerGame* functions, depending on the choices of the user. (first function reads two names, the other simply one, as the names sugest).

```cpp
void twoPlayerGame()
{
	int space, len, foundUser = 0, ok = 0;
	while (foundUser == 0)
	{
		cout << "Enter player 1 name : \n";
		cin.get(user1, 20);
		cin.get();
		len = strlen(user1);
		foundUser = 1;
		for (space = 0; space < len; space++)
			if (user1[space] < 'A' || user1[space] > 'z' || (user1[space] > 'Z' && user1[space] < 'a'))
				foundUser = 0;
		if (foundUser == 0)
			cout << "name contains invalid characters, try another one \n";
	}
	foundUser = 0;
	while (foundUser == 0)
	{
		cout << "Enter player 2 name : \n";
		cin.get(user2, 20);
		cin.get();
		len = strlen(user2);
		foundUser = 1;
		for (space = 0; space < len; space++)
			if (user2[space] < 'A' || user2[space] > 'z' || (user2[space] > 'Z' && user2[space] < 'a'))
				foundUser = 0;
		if (foundUser == 0)
			cout << "name contains invalid characters, try another one \n";
	}
}
void onePlayerGame()
{
	int foundUser = 0, len, space;
	while (foundUser == 0)
	{
		cout << "Enter name : \n";
		cin.get(user1, 20);
		cin.get();
		len = strlen(user1);
		foundUser = 1;
		for (space = 0; space < len; space++)
			if (user1[space] < 'A' || user1[space] > 'z' || (user1[space] > 'z' && user1[space] < 'a'))
				foundUser = 0;
		if (foundUser == 0)
			cout << "name contains invalid characters, try another one \n";
	}
}
```

For the game to actually work I chose to use two functions: *startOne* and *startTwo*. *startOne* means the player is playing against another person, while *startTwo* means the player is up against some random values generated by the program.

```cpp
void startOne()
{
	int progress = 0;
	tableSelection();
	while (progress < tableElements * tableElements - 1)
	{
		gameChangeX(game);
		progress++;
		if (checkX() == 1)
		{
			cout << user1 << " wins!" << endl << endl;
			break;
		}
		gameChange0(game);
		if (check0() == 1)
		{
			cout << user2 << " wins!" << endl << endl;
			break;
		}
		progress++;
	}
	if (check0() != 1 && checkX() != 1) cout << "It's a draw!" << endl;
	cout << "Final result is :" << endl;
	gameProgress(game);
}
```

The function that displays the current state of the game is called *gameProgress* and, through two different repetitive structures and through a *switch*, it masks the matrix and displays the proper values mentioned above: "-, x, 0" for 0, 1 and 2 respectively. 

```cpp
void gameProgress(int game[5][5])
{
	for (int line = 1; line <= tableElements; line++)
	{
		for (int column = 1; column <= tableElements; column++)
			switch (game[line][column])
			{
			case 0: cout << "- "; break;
			case 1: cout << "x "; break;
			case 2: cout << 0 << " "; break;
			}
		cout << endl;
	}
}
```

To advance the game uses two functions, one for x (*gameChangeX*) and one for 0 (*gameChange0*), to simply change the values of the selected elements (the square with the line and column picked out by the users). It checks to see if the chosen space is already taken and reads inputs until the given line and column are free. When the game is in single player mode I use two other functions, one to generate the square picked (function *randomNr*) and one to change the vaue accordingly (*gameChangePc*).

```cpp 
void gameChangeX(int game[5][5])
{
	int inputLine, inputColumn, ok = 0;
	cout << user1 << ", choose the line and column for x: ";
	cin >> inputLine >> inputColumn;
	while (ok == 0)
		if (game[inputLine][inputColumn] == 0)
			game[inputLine][inputColumn] = 1, ok = 1;
		else
		{
			cout << "space already filled, pick another slot: ";
			cin >> inputLine >> inputColumn;
		}
	gameProgress(game);
}
```

Function *randomNr* checks the number of lines and columns of the table (*tableElements*) and generates a random value between 1 and the current number of elements. *gameChangePC* uses this function to generate the values it checks and introduces into the table, displaying the current move on the screen.

```cpp
void randomNr()
{
	switch (tableElements)
	{
	case 3: {inputLine = rand() % 3 + 1; inputColumn = rand() % 3 + 1; } break;
	case 4: {inputLine = rand() % 4 + 1; inputColumn = rand() % 4 + 1; } break;
	}
}
void gameChangePC(int game[5][5])
{
	int ok = 0;
	srand(time(NULL));
	randomNr();
	while (ok == 0)
		if (game[inputLine][inputColumn] == 0)
			game[inputLine][inputColumn] = 2, ok = 1;
		else
			randomNr();
	cout << "PC's move is : \n";
	gameProgress(game);
}
```

The *checkX* and *check0* functions are almost identical. They're used one after the other after every change made to the matrix to see if the game's finished or if someone won. The function counts the number of elements equal to 1 (for x) or 2 (for 0). If the number of elements found on a line, column or diagonal is equal to *tableElements* then the the function returns 1 as a way to signalise that the checked user won (x or 0). If, at the end, the game isn't actually won by anyone then the function *start* displays the message *It's a draw!* on the screen. 

```cpp
int checkX()
{
	int nrLine, nrColumn, line, column;
	for (line = 1; line <= tableElements; line++)
	{
		nrLine = nrColumn = 0;
		for (column = 1; column <= tableElements; column++)
		{
			if (game[line][column] == 1)
				nrLine++;
			if (game[column][line] == 1)
				nrColumn++;
		}
		if (nrLine == tableElements || nrColumn == tableElements) return 1;
	}
	nrLine = nrColumn = 0;
	for (line = 1; line <= tableElements; line++)
	{
		if (game[line][line] == 1)
			nrLine++;
		if (game[line][tableElements + 1 - line] == 1)
			nrColumn++;
	}
	if (nrLine == tableElements || nrColumn == tableElements) return 1;
	return 0;
}
```

